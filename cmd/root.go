/*
Copyright Â© 2022 NAME HERE <EMAIL ADDRESS>

*/
package cmd

import (
	"fmt"
	"os"

	ct "github.com/opdev/controller-stamp/template"
	"github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "controller-stamp YourCamelKind apigroup apiImportPath apiImportAlias secondaryResource",
	Short: shortDesc,
	Long:  longDesc,
	Args:  cobra.ExactArgs(5),
	RunE: func(cmd *cobra.Command, args []string) error {
		pluralOverride, _ := cmd.Flags().GetString("set-plural") // TODO: handle error
		templateOverride, _ := cmd.Flags().GetString("template") // TODO: handle error

		primary := ct.ResourceData{
			APIImportPath:  args[2],
			APIImportAlias: args[3],
			APIGroup:       args[1],
			Kind:           args[0],
			KindPlural:     pluralOverride,
		}
		// TODO: fix this int exit code.
		// This layout is a retrofit/byproduct of not using
		// Cobra, and then deciding to use cobra after getting the initial
		// project scaffolded.
		//
		// Also, I need to migrate to using a proper runtime config and pass that
		// to our core logic below.
		if i := ExecuteFn(primary, templateOverride, args[4]); i != 0 {
			return fmt.Errorf("return code: %d", i)
		}

		return nil
	},
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	err := rootCmd.Execute()
	if err != nil {
		os.Exit(1)
	}
}

func init() {
	rootCmd.Flags().StringP("set-plural", "p", "", "Manually set the plural value for your Kind")
	rootCmd.Flags().StringP("template", "t", "StandardController", "Manually define the template to use.")
}

var shortDesc = "Generate generic go-based Kubernetes controllers and print to STDOUT."

var longDesc = `This tool will generate a Kubernetes controller that conforms
with what controllers generated by OperatorSDK and Kubebuilder look like.
resource as a secondary resource to your own custom resource. This is meant as

These controllers serve a very specific purpose: to manage a Kubernetes native
bootstrapping tool to get secondary resources managed quickly.

The inputs, today, are very specific. The format of the required looks something like
this.

	controller-stamp MySuperApp apps.example.com github.com/example/api/v1 superapiv1 deployments

This maps to the following data that the generator leverages:
	
	          Kind: MySuperApp
	      APIGroup: apps.example.com
	 APIImportPath: github.com/example/api/v1
	APIImportAlias: superapiv1
		For
	SecondaryResource: deployments

The generator will attempt to introspect the plural form, and the lowercase form of your
Kind, and use those values as well.
`
